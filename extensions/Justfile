set unstable := true

just := just_executable()
podman := require('podman')
podman-remote := which('podman-remote') || podman + ' --remote'
ext := env('CAYO_EXT',  shell('yq ".defaults.extension" extensions.yaml'))
variant := env('CAYO_VARIANT', shell('yq ".defaults.variant" extensions.yaml'))
version := env('CAYO_VERSION', shell('yq ".defaults.version" extensions.yaml'))
# print more logs to help debugging. Enable by setting CAYO_DEBUG env variable.
# Defaut to false.
debug := env('CAYO_DEBUG', '')
dnf_arch := env('CAYO_DNF_ARCH', 'x86_64')
arch := "x86_64"
# Default podman options
podman_opts := "--rm --arch=" + arch + " --security-opt label=disable"


[private]
default-inputs := '
: ${ext:=' + ext + '}
: ${variant:=' + variant + '}
: ${version:=' + version + '}
'

[private]
get-names := 'function ext-get() {
    if [ -z "$1" ]; then
      echo "ext-get: requires a key argument"
      exit 1
    fi
    KEY="${1}"
    data=$(IFS="" yq -Mr "explode(.)|.extensions|.' + ext + '-$variant-$version|.$KEY" extensions.yaml)
    echo ${data}
}
function ext-get-array() {
    if [ -z "$1" ]; then
      echo "ext-get: requires a key argument"
      exit 1
    fi
    KEY="${1}"
    data=$(IFS="" yq -Mr "explode(.)|.extensions|.' + ext + '-$variant-$version|.$KEY[]" extensions.yaml)
    echo ${data}
}
description="$(ext-get description)"
external_repos="$(ext-get-array external_repos)"
name="$(ext-get name)"
version_package="$(ext-get version_package)"
source_image="$(ext-get image)"
packages="$(ext-get-array packages)"
exclude_packages="$(ext-get-array exclude_packages)"
enable_repos="$(ext-get-array enable_repos)"
disable_repos="$(ext-get-array disable_repos)"
dnf_weak_deps="$(ext-get dnf_weak_deps)||true"
pre_commands="$(ext-get-array pre_commands)"
copr_repos="$(ext-get-array copr_repos)"
rpm_fusion_repos="$(ext-get-array rpm_fusion_repos)"
'

[group('Utility')]
check-valid-extension $ext="" $variant="" $version="":
    #!/usr/bin/env bash
    set -e
    {{ default-inputs }}
    data=$(IFS='' yq -Mr "explode(.)|.extensions|.{{ ext }}-$variant-$version" extensions.yaml)
    if [[ "null" == "$data" ]]; then
        echo "ERROR Invalid inputs: no matching extension definition found for: {{ ext }}-${variant}-${version}"
        exit 1
    fi

check $ext="" $variant="" $version="":
    #!/usr/bin/env bash
    set -e
    {{ default-inputs }}
    {{ get-names }}
    echo Name: $name
    echo Description: $description
    echo Source Image: $source_image
    echo Packages: "${packages[@]}"
    echo External Repo: $external_repo

build $ext="" $variant="" $version="":
    #!/usr/bin/env bash
    set -e
    {{ default-inputs }}
    {{ get-names }}
    echo building: $ext-$variant-$version
    {{ just }} clean $ext $variant $version
    {{ just }} download-rpms $ext $variant $version
    {{ just }} download-manual $ext $variant $version
    {{ just }} version $ext $variant $version
    {{ just }} inputs $ext $variant $version


clean $ext="" $variant="" $version="":
    #!/usr/bin/env bash
    set -euo pipefail
    {{ default-inputs }}
    if [[ -n "{{debug}}" ]]; then
      set -x
    fi

    if [[ "${UID}" == "0" ]]; then
        SUDO=""
    else
        SUDO="sudo"
    fi
    # change to the $ext directory
    cd {{ ext }}

    echo "🧹 Cleaning up files from previous builds"
    rm -rf inputs scripts digest version version_id
    rm -rf ./rpms
    rm -rf ./binaries
    ${SUDO} rm -rf ./rootfs
    rm -f ./*.raw

download-rpms $ext="" $variant="" $version="":
    #!/bin/bash
    set -euo pipefail
    if [[ -n "{{debug}}" ]]; then
      set -x
    fi

    {{ get-names }}
    # Skip this step if we have not been asked to download packages
    if [[ -z "$packages" ]]; then
        exit 0
    fi
    # change to the $ext directory
    cd {{ ext }}
    enablerepos=""
    if [[ -n "$enable_repos" && "$enable_repos" != "null" ]]; then
        for r in $enable_repos; do
            echo "➕ Enabling repo: ${r}"
            enablerepos+=" --enablerepo=${r}"
        done
    fi

    disablerepos=""
    if [[ -n "$disable_repos"  && "$disable_repos" != "null" ]]; then
        for r in $disable_repos; do
            echo "➖ Disabling repo: ${r}"
            disablerepos+=" --disablerepo=${r}"
        done
    fi

    dnf_arch=""
    if [[ -z "{{dnf_arch}}" ]]; then
        dnf_arches="noarch {{arch}}"
    else
        dnf_arches="{{dnf_arch}}"
    fi
    for a in ${dnf_arches}; do
        dnf_arch+="--arch=${a} "
    done

    dnf_opts=""
    if [[ "$dnf_weak_deps" == false ]]; then
        dnf_opts="--setopt=install_weak_deps=False"
    fi
    if [[ -n "$exclude_packages" ]]; then
        excluded_packages="$(echo "$exclude_packages" | xargs)"
        for p in ${excluded_packages}; do
            echo "➖ Excluding package: ${p}"
            dnf_opts+=" --exclude=${p}"
        done
    fi

    packages="$(echo "${packages[@]}" | xargs)"

    pre_commands=""
    if [[ -n "$pre_commands" && "$pre_commands" != "null" ]]; then
        pre_commands+="${pre_commands[@]} ; "
    fi
    if [[ -n "${copr_repos[@]}" ]]; then
        pre_commands+="dnf install -y dnf5-plugins"
        for r in "${copr_repos[@]}"; do
            pre_commands+=" ; dnf copr enable -y ${r}"
        done
        pre_commands+=" ; "
    fi
    if [[ -n "$external_repos" && "$external_repos" != "null" ]]; then
        pre_commands+="dnf install -y dnf5-plugins"
        for r in "${external_repos[@]}"; do
            pre_commands+=" ; dnf config-manager addrepo --from-repofile=${r}"
        done
        pre_commands+=" ; "
    fi

    if [[ -n "$rpm_fusion_repos" && "$rpm_fusion_repos" != "null" ]]; then
        release=$(podman run {{podman_opts}} "$source_image" \
            bash -c 'rpm -E %fedora' | tr -d '\n')
        for r in ${rpm_fusion_repos[@]}; do
            if [[ "${r}" != "free" ]] && [[ "${r}" != "nonfree" ]]; then
                echo "Unrecognized RPM Fusion repo: ${r}"
                exit 1
            fi
            echo "➕ Enabling RPM Fusion repo: '${r}'"
            pre_commands+=" dnf install -y https://mirrors.rpmfusion.org/${r}/fedora/rpmfusion-${r}-release-${release}.noarch.rpm ;"
        done
    fi

    mkdir -p ../.dnf-cache

    mkdir rpms
    cd rpms

    echo "⬇️ Downloading packages (${dnf_arches}): ${packages[@]}"
    {{ podman }} run -ti {{podman_opts}} \
        --volume "${PWD}:/var/srv" \
        --volume "${PWD}/../../.dnf-cache:/var/cache/libdnf5" \
        --workdir "/var/srv" \
        "$source_image" \
        bash -xc "export FORCE_COLUMNS=100 && ${pre_commands}dnf download --resolve ${dnf_arch} ${dnf_opts} ${disablerepos} ${enablerepos} ${packages}"


download-manual $ext="" $variant="" $version="":
    #!/bin/bash
    set -euo pipefail
    if [[ -n "{{debug}}" ]]; then
      set -x
    fi

    {{ get-names }}
    cd {{ ext }}
    # Skip this step if there is no file named "download-manual.sh" in the extension directory
    if [[ ! -f "download-manual.sh" ]]; then
        echo "❌ Skipping manual download, no 'download-manual.sh' script found in the extension directory."
        exit 0
    fi

    echo "⬇️ Downloading manual files"
    {{ podman }} run -ti {{podman_opts}} \
        --volume "${PWD}:/var/srv" \
        --workdir "/var/srv" \
        "$source_image" \
        bash -xc "download-manual.sh"

version $ext="" $variant="" $version="":
    #!/bin/bash
    set -euo pipefail
    if [[ -n "{{debug}}" ]]; then
      set -x
    fi
    {{ get-names }}
    cd {{ ext }}
    package_version() {
        rpm="${1}"
        epoch="$(rpm -qp --queryformat '%{EPOCH}' ${rpm})"
        version="$(rpm -qp --queryformat '%{VERSION}-%{RELEASE}' ${rpm})"
        if [[ "${epoch}" == "(none)" ]]; then
            epoch=""
        else
            epoch="${epoch}-"
        fi
        echo "${epoch}${version}" > ./version
    }

    echo "🏷️ Writing down version"

    if [[ -n "$version_package"  && "$version_package" != "null" ]]; then
        if [[ $(ls rpms/*.rpm | grep -cE "^rpms/$version_package-[0-9]" ) -ne 1 ]]; then
            echo "More than one package matched: $version_package."
            exit 1
        fi
        rpm="$(ls rpms/*.rpm | sort -h | grep -E "^rpms/$version_package-[0-9]" | head -1)"
        package_version "${rpm}"
        exit 0
    fi

    if [[ -z "$packages" ]]; then
        echo "No package listed. You must define the 'version' recipe in your justfile for this sysext."
        exit 1
    fi

    packages=($(echo "${packages[@]}" | xargs))

    if [[ ${#packages[@]} -ne 1 ]]; then
        if [[ $(ls rpms/*.rpm | grep -cE "^rpms/$name-[0-9]") -ne 1 ]]; then
            echo "More that one package listed. Set 'version_package' or define the 'version' recipe in your justfile for this sysext."
            exit 1
        fi
        rpm="$(ls rpms/*.rpm | sort -h | grep -E "^rpms/$name-[0-9]" | head -1)"
        package_version "${rpm}"
        exit 0
    fi

    # Only one package listed, let's use its version
    rpm="$(ls rpms/${packages[0]}*.rpm | sort -h | head -1)"
    package_version "${rpm}"

inputs $ext="" $variant="" $version="":
    #!/bin/bash
    set -euo pipefail
    if [[ -n "{{debug}}" ]]; then
      set -x
    fi
    {{ get-names }}
    cd {{ ext }}
    echo "🏷️ Writing down inputs"

    # Make sure that we always have a version set
    version=""
    if [[ -f ./version ]]; then
        version="$(cat ./version)"
    else
        version=$(podman run {{podman_opts}} "$source_image" \
            bash -c 'source /etc/os-release ; echo -n ${OSTREE_VERSION}')
    fi
    # Remove special characters from the version
    version="$(cat ./version | sed "s/\^/_/" | sed "s/:/_/")"
    # Write back version to file
    echo "${version}" > ./version

    # Get and store name, tag and digest for the container image used to build the sysext
    echo ""$source_image"@$(podman inspect "$source_image" | jq -r '.[0].Digest')" > ./digest

    # Store version_id (Fedora release)
    version_id=$(podman run {{podman_opts}} "$source_image" \
        bash -c 'source /etc/os-release ; echo -n ${VERSION_ID}')
    echo "${version_id}" > ./version_id

    # Store the hashes of the RPMs used to build the sysext
    if [[ -d ./rpms ]]; then
        cd rpms
        sha256sum *.rpm >> ../inputs
        cd ..
    fi
    # Store the hashes of all the files added to the sysext
    # if [[ -n "files" ]]; then
    #     for f in files; do
    #         find ${f} -type f | sort -h | xargs sha256sum >> ./inputs
    #     done
    # fi
    # Make sure that we have an inputs file in all cases
    touch ./inputs

    # Store the hashes of the scripts used to build the sysext
    sha256sum ../Justfile >> ./scripts
    cd ..
    sha256sum extensions.yaml >> ./${ext}/scripts

[group('Utility')]
explode-yaml:
    yq -r "explode(.)|.extensions" extensions.yaml